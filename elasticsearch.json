#construct table
user (
user_id: int
name: string
date: datetime
)

#http://elasticsearch-cheatsheet.jolicode.com/#goto_title_2
GET /blog/post/_validate/query?explain
{
"query": {
"match": {
"title": "Smith"
}
}
}


#delete index
DELETE /gb
#create mapping
PUT /gb GET /blog/post/_validate/query?explain
{
"query": {
"match": {
"title": "Smith"
}
}
}
{
"mappings": {
"tweet" : {
"properties" : {
"tweet" : {
"type" :    "string",
"analyzer": "english"
},
"date" : {
"type" :   "date"
},
"name" : {GET /blog/post/_validate/query?explain
{
"query": {
"match": {
"title": "Smith"
}
}
}
"type" :   "string"
},
"user_id" : {
"type" :   "long"
}
}
}
}
}

#post index: gb[index=db]/tweet[type=table]/1[id]
POST gb/tweet/1
{
"tweet":    "However did I manage before Elasticsearch?",
"date":     "2014-09-14",
"name":     "Mary Jones",
"user_id":  1
}

_all ~ "However did I manage before Elasticsearch? 2014-09-14 Mary Jones 1"

#Query examples
WHERE name    = "John Smith"
AND user_id = 2
AND date    => "2014-09-15"
#Query elastic;
#https://www.elastic.co/guide/en/elasticsearch/reference/current/query-dsl-range-query.html
#https://www.elastic.co/guide/en/elasticsearch/guide/1.x/query-dsl-intro.html
GET gb/tweet/_search
{
"query": {
"bool":{
"must": { "match": {"user_id": 2} },
"must": { "match": {"name": "John Smith"} },
"must": { "range": {"date": {	"gte": "2014-09-15","format": "yyyy-MM-dd" }} }
}
}
}

#WHERE user_id=2
GET gb/tweet/_search
{
"query":{
"match": {GET /blog/post/_validate/query?explain
{
"query": {
"match": {
"title": "Smith"
}
}
}
"user_id": 2
}
}
}

#sorting filter
GET gb/_search
{
"query" : {
"filtered" : {
"filter" : { "term" : { "user_id" : 3 }}
}
},
"sort": { "date": { "order": "desc" }}
}

GET gb/_search
{
"query" : {
"filtered" : {
"query":   { "match": { "tweet": "i" }},
"filter" : { "term" : { "user_id" : 3 }}
}
},
"sort": [
{ "date":   { "order": "desc" }},
{ "_score": { "order": "desc" }}
]
}

#https://www.elastic.co/guide/en/elasticsearch/guide/1.x/boosting-by-popularity.html
#post data for blog
PUT /blogposts/post/1
{
"title":   "About popularity",
"content": "In this post we will talk about...",
"votes":   6
}

Imagine that we have a website that hosts blog posts and enables users to vote for the blog posts that they like. We would like more-popular posts to appear higher in the results list, but still have the full-text score as the main relevance driver. We can do this easily by storing the number of votes with each blog post:
#requirement: amout votes is more then is high
GET /blogposts/post/_search
{
"query": {
"function_score": {
"query": {
"multi_match": {
"query":    "popularity",
"fields": [ "title", "content" ]
}
},
"field_value_factor": {
"field": "votes"
}
}
}
}
#new_score = old_score * number_of_votes

https://www.elastic.co/guide/en/elasticsearch/guide/1.x/script-score.html



